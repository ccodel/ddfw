/** @file assignment.c
 *  @brief Implements functions to initialize and change the Boolean variable
 *         truth assignment while running DDFW.
 *
 *  While the assignment (and its associated arrays and variables) are housed
 *  in and allocated by global_data.h/.c, the ability to flip variables
 *  within the assignment are declared here.
 *
 *  @author Cayden Codel (ccodel@andrew.cmu.edu)
 *
 *  @bug No known bugs.
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "assignment.h"
#include "global_data.h"
#include "weight_reducer.h"
#include "initializer.h"
#include "logger.h"
#include "xmalloc.h"
#include "neighborhood.h"
#include "verifier.h"


static int *unsat_clause_idxs;

// TODO experimental
long ddfw_plus_counter = 0;
int ddfw_plus_boolean = 0;
int ddfw_reweighting_enabled = 0;

void allocate_assignment_memory(void) {
  unsat_clause_idxs = xmalloc(num_clauses * sizeof(int));
}

static void add_unsat_clause(const int c_idx) {
  if (unsat_clause_idxs[c_idx] == -1) {
    unsat_clause_idxs[c_idx] = num_unsat_clauses;
    unsat_clauses[num_unsat_clauses] = c_idx;
    num_unsat_clauses++;
    total_unsat_clause_weight += clause_weights[c_idx];
  }
}

static void remove_unsat_clause(const int c_idx) {
  const int idx = unsat_clause_idxs[c_idx];
  if (idx != -1) {
    num_unsat_clauses--;

    // If idx is not at the end, move the end of members to this index
    if (idx != num_unsat_clauses) {
      const int end_clause = unsat_clauses[num_unsat_clauses];
      unsat_clauses[idx] = end_clause;
      unsat_clause_idxs[end_clause] = idx;
    }
    
    unsat_clause_idxs[c_idx] = -1;
    total_unsat_clause_weight -= clause_weights[c_idx];
  }
}

// TODO experimental
/*
void reset_to_ddfw_plus_weightings(void) {
  ddfw_plus_counter++;
  if (ddfw_plus_counter >= num_clauses) {
    // printf("Resetting to ddfw plus at %ld flips\n", num_flips);
    ddfw_plus_counter = 0;
    if (!ddfw_plus_boolean) {
      ddfw_plus_boolean = 1;
      const double w_to_add = init_clause_weight / 2.0;
      for (int c = 0; c < num_clauses; c++) {
        clause_weights[c] += w_to_add;
      }
    } else {
      ddfw_plus_boolean = 0;
      const double sw = init_clause_weight * 1.5;
      for (int c = 0; c < num_clauses; c++) {
        if (clause_num_true_lits[c] == 0) {
          clause_weights[c] = init_clause_weight;
        } else {
          clause_weights[c] = sw;
        }
      }
    }

    reset_cost_reducing_struct();
    reset_cost_compute_struct();
    reset_critical_weights_struct();
    compute_critical_weights_struct();
    initialize_neighborhoods();
  }
}
*/

void compute_unsat_after_assignment(void) {
  memset(clause_num_true_lits, 0, num_clauses * sizeof(int));
  memset(clause_lit_masks, 0, num_clauses * sizeof(int));
  memset(unsat_clause_idxs, 0xff, num_clauses * sizeof(int));
  num_unsat_clauses = 0;
  total_unsat_clause_weight = 0;

  for (int v = 1; v <= num_vars; v++) {
    const int true_idx = (assignment[v]) ? LIT_IDX(v) : NEGATED_IDX(LIT_IDX(v));
    int *clauses = literal_clauses[true_idx];
    const int occ = literal_occ[true_idx];
    for (int c = 0; c < occ; c++) {
      const int c_idx = clauses[c];
      clause_num_true_lits[c_idx]++;
      clause_lit_masks[c_idx] ^= true_idx;
    }
  }

  // Now add any false clauses to the array
  for (int c = 0; c < num_clauses; c++) {
    if (clause_num_true_lits[c] == 0) {
      add_unsat_clause(c);
    }
  }
}


/** @brief Generates a random variable assignment for the global formula.
 *
 *  A random assignment is chosen for the num_vars variables. The random
 *  assignment is generated by storing random numbers into the assignment
 *  bitvector in the global formula. A bit of 1 indicates that the variable
 *  is set to true and its negation is false.
 *
 *  The clauses and literals are updated to reflect the random assignment,
 *  which includes
 *    
 *    - Sat
 *    - Mask
 *    - TODO
 *
 *  Note that the function does not initialize the srand() randomization
 *  library. Such randomization should be handled at command-line parsing.
 *
 *
 *   TODO clean up docs
 *  1. A random assignment is chosen for the num_vars variables.
 *     The random assignment is generated by looping over each
 *     "slot" in the assignment variable and assigning it a random
 *     bit. A 1 in slot i indicates that x_i is assigned to true.
 *
 *  2. The clauses are looped over to determine satisfiability.
 *     After a random assignment is generated, many clauses may evaluate
 *     to true. Looping over the clauses determines how many literals in
 *     each clause are true, and overall how many clauses are true.
 *     Note the usage of an XOR satisfiability mask in each clause to help
 *     determine which literal is the last one keeping a clause true in
 *     the case that clause->sat_lits is 1.
 */
void generate_random_assignment(void) {
  log_str("c Randomizing assignment\n");

  // Give random bits to assignment
  for (int i = 1; i <= num_vars; i++) {
    assignment[i] = (char) (rand() & 0x1);
  }

  initialize_structures_after_assignment();
  best_num_unsat_clauses = num_unsat_clauses;
  verify_clauses_and_assignment();
}

/** @brief Takes an index of a variable to flip and flips it in the assignment.
 *
 *  The function will change the truth value of the variable and update the
 *  appropriate structures.
 *
 *  @param lit_idx The index into the literals array of the literal to flip.
 */
void flip_variable(const int v_idx) {
  assignment[v_idx] = !assignment[v_idx];
  add_weight_compute_var(v_idx);

  // Determine which literal has the truth value, to flip correct clauses
  const int a = assignment[v_idx];
  const int true_idx = (a) ? LIT_IDX(v_idx) : NEGATED_IDX(LIT_IDX(v_idx));;
  const int false_idx = NEGATED_IDX(true_idx);

  const int true_occ = literal_occ[true_idx];
  const int false_occ = literal_occ[false_idx];

  // Since l is being set to false, then by definition, it cannot be a sat lit
  // TODO shift responsibility to weight reducer
  literal_critical_sat_weights[false_idx] = 0;

  // For each clause containing false_idx, set it to false
  int *clauses = literal_clauses[false_idx];
  for (int c = 0; c < false_occ; c++) {
    const int c_idx = clauses[c];

    clause_num_true_lits[c_idx]--;
    const int true_lits = clause_num_true_lits[c_idx];
    clause_lit_masks[c_idx] ^= true_idx;

    // In the case where the clause now has 0 true literals,
    //   all literals become critical, and may be added to cost compute
    if (true_lits == 0) {
      add_unsat_clause(c_idx);

      const int clause_size = clause_sizes[c_idx];
      int *lits = clause_literals[c_idx];
      const weight w = clause_weights[c_idx];
      for (int l = 0; l < clause_size; l++) {
        const int lit = lits[l];
        add_weight_compute_var(VAR_IDX(lit)); 
        literal_unsat_weights[lit] += w;
      }

      update_neighborhoods_on_flip(c_idx);
    } else if (true_lits == 1) {
      // If instead the clause has 1 true literal, only the last true
      // literal is critical and can make the clause false if flipped
      // Get the last true literal from the literal mask
      const int mask_lit = clause_lit_masks[c_idx];
      add_weight_compute_var(VAR_IDX(mask_lit));
      literal_critical_sat_weights[mask_lit] += clause_weights[c_idx];
    }
  }

  // For each clause containing true_idx, set it to true
  clauses = literal_clauses[true_idx];
  for (int c = 0; c < true_occ; c++) {
    const int c_idx = clauses[c];

    // Add literal to sat XOR mask
    clause_num_true_lits[c_idx]++;
    const int true_lits = clause_num_true_lits[c_idx];
    const int mask_before = clause_lit_masks[c_idx]; // See else if case
    clause_lit_masks[c_idx] ^= true_idx;

    // If the clause was just made true, then all literals may now reduce weight
    if (true_lits == 1) {
      remove_unsat_clause(c_idx);

      const int clause_size = clause_sizes[c_idx];
      int *lits = clause_literals[c_idx];
      const weight w = clause_weights[c_idx];
      literal_critical_sat_weights[true_idx] += w;
      for (int l = 0; l < clause_size; l++) {
        const int lit = lits[l];
        add_weight_compute_var(VAR_IDX(lit));
        literal_unsat_weights[lit] -= w;
      }

      update_neighborhoods_on_flip(c_idx);
    } else if (true_lits == 2) {
      // Literal has been made non critical
      add_weight_compute_var(VAR_IDX(mask_before));
      literal_critical_sat_weights[mask_before] -= clause_weights[c_idx];
    }
  }
 
  if (get_verbosity() == VERBOSE) {
    log_assignment();
  }

  if (num_unsat_clauses < best_num_unsat_clauses) {
    best_num_unsat_clauses = num_unsat_clauses;
    best_flip_num = num_flips;
    memcpy(best_assignment, assignment, (num_vars + 1) * sizeof(char));
    num_flips_since_improvement = 0;
  } else {
    //ddfw_plus_counter++;
    num_flips_since_improvement++;
    //if (ddfw_reweighting_enabled) {
    //  reset_to_ddfw_plus_weightings();
    //}
  }

  num_flips++;
}

/** @brief Restores the structures that the clause file is in charge of
 *         back to the best assignment found so far.
 */
void restore_to_best_assignment(void) {
  memcpy(assignment, best_assignment, (num_vars + 1) * sizeof(char));
  num_flips_since_improvement = 0;
  initialize_structures_after_assignment();
  verify_clauses_and_assignment();
}
