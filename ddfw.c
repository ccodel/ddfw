/** @file ddfw.c - Divide and Distribute Fixed Weights
 *  @brief An implementation of the DDFW algorithm, as presented in 
 *         the paper: "Neighbourhood Clause Weight Redistribution in 
 *                     Local Search for SAT" [Ishtaiwi, Thornton, Sattar, Pham]
 *
 *  @usage ./ddfw [-hv] -f <filename> [-s <seed>] [-t <timeout>]
 *
 *  The algorithm is implemented as TODO...
 *
 *  This implementation of DDFW assumes that:
 *
 *   - No clause has more than MAX_CLAUSE_LENGTH literals in it
 *   - No clause contains a tautology (e.g. (x v !x))
 *
 *  @author Cayden Codel (ccodel@andrew.cmu.edu)
 *  
 *  @bug No known bugs.
 */

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <getopt.h>
#include <time.h>

#define MAX_CLI_ARGS  9

#define verbose_printf(...)  ((verbose) ? printf(__VA_ARGS__) : 0)

/** Some simple helper functions. */
/** Calculates the absolute value of the number passed in. */
#define ABS(x)     (((x) < 0) ? -x : x)

/** Finds the minimum of two numbers. */
#define MIN(x, y)  (((x) < (y)) ? (x) : (y))

/** Finds the maximum of two numbers. */
#define MAX(x, y)  (((x) > (y)) ? (x) : (y))

/** Default starting weight for each clause. */
#define DEFAULT_CLAUSE_WEIGHT                (1.0)

/** Default number of seconds to loop before timing out. 
 *  Can be toggled with the -t <timeout_secs> flag at the command line.
 **/
#define DEFAULT_TIMEOUT_SECS                  (10)

/** Default number of times a loop body is run before the number of elapsed
 *  seconds is checked. Not currently configurable.
 *
 *  TODO maybe define this based on some computed runtime quantity? Make
 *       smaller based on number of clauses/literals?
 */
#define DEFAULT_LOOPS_PER_TIMEOUT_CHECK   (100)

#define COMMENT_LINE ('c')
#define PROBLEM_LINE ('p')

/** Takes a literal and returns the index into the array *literals. */
#define LIT_IDX(x)   (((x) < 0) ? (num_vars + -(x) - 1) : ((x) - 1))

/** Takes a converted LIT_IDX and returns if the index is a negated literal */
#define IS_NEGATED(x)  (((x) >= num_vars) ? 1 : 0)

#define NEGATED_IDX(x) (((x) >= num_vars) ? ((x) - num_vars) : ((x) + num_vars))

/** Takes a converted LIT_IDX and converts back to var_idx for *assignment. */
#define VAR_IDX(x)   (((x) >= num_vars) ? ((x) - num_vars) : (x))

/** Used to define a buffer to store literals in during CNF I/O. */
#define MAX_CLAUSE_LENGTH 10000 // TODO remove this limit later

typedef struct clause {
  int size;      // Number of literals in the clause
  int sat_lits;  // Counter on number of unsatisfied literals
  int sat_mask;  // XOR of all literals that satisfy the clause
  double weight; // Weight of the clause
  int *literals; // Array of literal indexes, already converted through LIT_IDX
} clause_t;

typedef struct literal {
  int occurrences;
  int *clause_indexes;  // Array of clause indexes into *clauses.
} literal_t;

/** Number of variables (x_i), literals (x_i, !x_i), clauses */
static int num_lits, num_vars, num_clauses;

static literal_t *literals; // Positive literals in front half
static clause_t *clauses;
static char *assignment;    // TODO change to bitvector later?
static int unsat_clauses;   // Counter of unsatisfied clauses

static int seed;            // Optional randomization seed
static int timeout_secs = DEFAULT_TIMEOUT_SECS;  // Seconds until timeout

static int clause_id_buf[MAX_CLAUSE_LENGTH]; // TODO move later?

/** Information generated by algorithm */
static int *greatest_reduction_cost_lits;
static int num_reducing_lits;

/** Other information to track */
static int min_clause_size = INT_MAX, max_clause_size = 0;
static int min_lit_occurrences = INT_MAX, max_lit_occurrences = 0;

////////////////////////////////////////////////////////////////////////////////
// Printing, debugging, and usage
////////////////////////////////////////////////////////////////////////////////

/** Whether verbose printing should be enabled. Disabled, by default. */
static int verbose = 0;

static void print_usage(char *path, FILE *f) {
  fprintf(f, "Usage: %s [-vh] -f <filename> [-s <seed>] [-t <timeout>]\n", 
      path);
}

static void print_help(char *path, FILE *f) {
  fprintf(f, "%s: Divide and Distribute Fixed Weights\n", path);
  fprintf(f, "  -f <filename>  Provide a .cnf file.\n");
  fprintf(f, "  -h             Display this help message.\n");
  fprintf(f, "  -s <seed>      Provide an optional randomization seed.\n");
  fprintf(f, "  -t <timeout>   Provide an optional seconds until timeout.\n");
  fprintf(f, "  -v             Turn on verbose printing.\n");
}

static void print_clause(clause_t *c, FILE *f) {
  fprintf(f, "(");
  int size = c->size;
  int *lits = c->literals;
  for (int i = 0; i < size; i++) {
    int var_idx = VAR_IDX(ABS(lits[i]));
    int negated = IS_NEGATED(lits[i]);

    if ((assignment[var_idx] && !negated) ||
        (!assignment[var_idx] && negated)) {
      fprintf(f, "[%d]", lits[i]);
    } else {
      fprintf(f, "%d", lits[i]);
    }

    if (i != size - 1)
      fprintf(f, " ");
    else
      fprintf(f, ") -> %d\n", c->sat_lits);
  }
}

/** @brief Prints general information per loop(?)
 */
static void print_loop_info() {
  printf("c ----------------------------------------------------------\n");
  printf("c Assignment:\nc       ");
  for (int i = 0; i < num_vars; i++) {
    if (assignment[i])
      printf(" %d ", i + 1);
    else
      printf("%d ", -(i + 1));
    if (((i + 1) & 0x7) == 0)
      printf("\nc       ");
  }
  printf("\n");

  double unsat_weight = 0.0;
  for (int c = 0; c < num_clauses; c++) {
    if (clauses[c].sat_lits == 0)
      unsat_weight += clauses[c].weight;
  }
  printf("c  Unsat clauses: %d, unsat weight: %.2f\n", 
      unsat_clauses, unsat_weight);
}

////////////////////////////////////////////////////////////////////////////////
// File processing and memory allocation
////////////////////////////////////////////////////////////////////////////////

// TODO make every "important" variable static global because apparently
//      setting up arguments onto the stack is very expensive

// TODO global variables into a state struct? Examine later...

/** @brief Allocates enough memory to store the information from the CNF file.
 *
 *  @note The results returned from malloc() are not checked for NULL.
 */
static void alloc_memory() {
  verbose_printf("Allocating memory\n");
  literals = malloc(num_lits * sizeof(literal_t));
  clauses = malloc(num_clauses * sizeof(clause_t));
  assignment = malloc(num_vars * sizeof(char));
  greatest_reduction_cost_lits = malloc(num_lits * sizeof(int));
}

// TODO name
// Do some meta processing on information gathered from .cnf file
static void meta_process_file() {
  for (int i = 0; i < num_lits; i++) {
    min_lit_occurrences = MIN(min_lit_occurrences, literals[i].occurrences);
    max_lit_occurrences = MAX(max_lit_occurrences, literals[i].occurrences);
  }

  // Loop through each literal and find the clauses they are in
  // TODO this is horrible efficiency, think of dynamic data structure for later
  for (int i = 0; i < num_lits; i++) {
    literal_t *l = &literals[i];
    l->clause_indexes = malloc(l->occurrences * sizeof(int));
    int clause_idx = 0;
    if (l->clause_indexes == NULL) {
      fprintf(stderr, "c Error: Out of memory\n");
      exit(-1);
    }

    // Loop through all clauses and see if the literal is in it
    for (int c = 0; c < num_clauses; c++) {
      clause_t *clause = &clauses[c];
      int size = clause->size;
      int *lit_idx = clause->literals;
      for (int s = 0; s < size; s++) {
        if (*lit_idx == i) {
          l->clause_indexes[clause_idx++] = c;
        }
        lit_idx++;
      }
    }
  }
}

/** @brief Parses the CNF file with the provided file name.
 *
 *  
 *  @param filename The name of the CNF file to open.
 *  @return void, but will call exit(-1) if an error is encountered.
 *
 */
static void parse_cnf_file(char *filename) {
  FILE *f = fopen(filename, "r");
  if (f == NULL) {
    fprintf(stderr, "c Error: Not able to open the file: %s\n", filename);
    exit(-1);
  } else {
    verbose_printf("Successfully opened file %s\n", filename);
  }

  // Keep scanning the file until the header line is found
  int problem_found = 0;
  while (!problem_found) {
    char c = fgetc(f);
    switch (c) {
      case COMMENT_LINE:
        verbose_printf("Found comment line, skipping\n");
        fscanf(f, "%*[^\n]");
        continue;
      case PROBLEM_LINE:
        verbose_printf("Found problem line\n");
        fscanf(f, "%*s %d %d\n", &num_vars, &num_clauses);
        num_lits = num_vars * 2;
        alloc_memory(); // TODO name?
        problem_found = 1;
        break;
    }
  }
  
  // Now scan in all the clauses
  verbose_printf("Scanning clauses\n");
  int scanned_clauses = 0;
  while (scanned_clauses < num_clauses) {
    int lit = 0, clause_size = 0;
    do {
      fscanf(f, "%d", &lit);
      if (lit != 0) {
        // New literal for the clause - count occurrence, place into buffer
        int idx = LIT_IDX(lit);
        literals[idx].occurrences++;
        clause_id_buf[clause_size] = idx;
        clause_size++;
      } else {
        // Finished with this clause, since encountered a 0
        // Instantiate new clause with default weight and copy over literal idxs
        clause_t *clause = &clauses[scanned_clauses++];
        clause->size = clause_size;
        clause->weight = DEFAULT_CLAUSE_WEIGHT;
        clause->literals = malloc(clause_size * sizeof(int));
        memcpy(clause->literals, clause_id_buf, clause_size * sizeof(int));

        // Update some meta-information
        min_clause_size = MIN(min_clause_size, clause_size);
        max_clause_size = MAX(max_clause_size, clause_size);
      }
    } while (lit != 0);
  }

  verbose_printf("Done with I/O, processing CNF file\n");
  meta_process_file();
  verbose_printf("Done meta processing, onto the algorithm!\n");
  fclose(f);
}

////////////////////////////////////////////////////////////////////////////////
// DDFW algorithm implementation
////////////////////////////////////////////////////////////////////////////////

/** @brief Takes the in index of the literal to flip and flips it.
 *
 *  The flip makes a change in the assignment array.
 *
 *  @param lit_idx The index of the literal to flip.
 */
static void flip_literal(int lit_idx) {
  verbose_printf("c Flipping %d\n", lit_idx);

  int var_idx = VAR_IDX(lit_idx);
  int not_idx = NEGATED_IDX(lit_idx);
  literal_t *l = &literals[lit_idx];
  literal_t *not_l = &literals[not_idx];

  int occ = l->occurrences;
  int not_occ = not_l->occurrences;

  // For each clause l is in, set to false
  for (int c = 0; c < occ; c++) {
    int c_idx = l->clause_indexes[c];
    clause_t *cl = &clauses[c_idx];

    // Remove literal from sat XOR mask
    cl->sat_lits--;
    cl->sat_mask ^= lit_idx;

    if (cl->sat_lits == 0) {
      unsat_clauses++;
      verbose_printf("c Unsatisfied clause %d\n", c_idx);
    }
  }

  // For each clause !l is in, set to true
  for (int c = 0; c < not_occ; c++) {
    int c_idx = not_l->clause_indexes[c];
    clause_t *cl = &clauses[c_idx];

    // Add literal to sat XOR mask
    cl->sat_lits++;
    cl->sat_mask ^= not_idx;

    if (cl->sat_lits == 1) {
      unsat_clauses--;
      verbose_printf("c Satisfied clause %d\n", c_idx);
    }
  }

  // Affect assignment array
  assignment[var_idx] = !assignment[var_idx];
}

/** @brief Initializes structures to run the DDFW algorithm.
 *
 *  A few things need to be initialized in order to run DDFW.
 *
 *  1. A random assignment is chosen for the num_vars variables.
 *     The random assignment is generated by looping over each
 *     "slot" in the assignment variable and assigning it a random
 *     bit. A 1 in slot i indicates that x_i is assigned to true.
 *
 *  2. The clauses are looped over to determine satisfiability.
 *     After a random assignment is generated, many clauses may evaluate
 *     to true. Looping over the clauses determines how many literals in
 *     each clause are true, and overall how many clauses are true.
 *     Note the usage of an XOR satisfiability mask in each clause to help
 *     determine which literal is the last one keeping a clause true in
 *     the case that clause->sat_lits is 1.
 */
static void initialize_algorithm() {
  // Provide randomization seed, if one was provided
  if (seed != 0) {
    verbose_printf("Accepted seed %d\n", seed);
    srand(seed);
  }

  // Randomize initial assignment
  for (int i = 0; i < num_vars; i++) {
    assignment[i] = (rand() & 0x1);
    if (assignment[i])
      verbose_printf("[%d] ", i + 1);
    else
      verbose_printf("%d ", i + 1);
  }
  verbose_printf("\n");

  // Iterate through clauses to find which are satisfied
  for (int i = 0; i < num_clauses; i++) {
    clause_t *c = &clauses[i];
    c->sat_lits = 0;
    c->sat_mask = 0;

    // Go through each literal to see which are satisfied
    int *lits = c->literals;
    int size = c->size;
    for (int l = 0; l < size; l++) {
      int var_idx = VAR_IDX(lits[l]);
      int negated = IS_NEGATED(lits[l]);

      // If the literal evalutes to true, update clause information
      if ((assignment[var_idx] && !negated) ||
          (!assignment[var_idx] && negated)) {
        c->sat_lits++;
        c->sat_mask ^= lits[l];
      }
    }

    if (c->sat_lits == 0)
      unsat_clauses++;

    /*
    if (verbose)
      print_clause(c, stdout);
      */
  }

  verbose_printf("There are %d unsatisfied clauses\n", unsat_clauses);
}

/** @brief Finds those literals that cause a positive change in weighted
 *         cost if flipped and stores them in greatest_reduction_cost_lits.
 *         Stores the number of such literals in num_reducing_lits.
 *
 *  According to the DDFW algorithm, the first thing done per each loop body
 *  is to "find and return a list L of literals causing the greatest reduction
 *  in weighted cost delta(w) when flipped."
 *
 *  TODO CURRENTLY INEFFICIENT
 *  To do so, the literals are looped over. The change in weighted cost for
 *  literal l is defined as the cost lost minus the cost gained from making
 *  clauses unsatisfied.
 *
 *  Let W(l) be the total weight of clauses with l or !l, sat or unsat.
 *  Then if delta(w) for l is W, delta(w) for !l is "break." TODO
 *
 */
static void find_cost_reducing_literals() {
  // Set the index to 0 to fill in "positive" literals as we go along
  num_reducing_lits = 0;

  for (int i = 0; i < num_vars; i++) {
    double satisfied_weight = 0.0;   // Weight "lost" when sat clauses on flip
    double unsatisfied_weight = 0.0; // Weight "gained" on unsat clauses
    int assigned = assignment[i];
    literal_t *l, *not_l;
    if (assigned) {
      l = &literals[i];
      not_l = &literals[i + num_vars];
    } else {
      l = &literals[i + num_vars];
      not_l = &literals[i];
    }

    int occ = l->occurrences;
    int not_occ = not_l->occurrences;

    // Loop over satisfied claueses containing the "true" literal
    for (int c = 0; c < occ; c++) {
      int c_idx = l->clause_indexes[c];
      clause_t *cl = &clauses[c_idx];
      if (cl->sat_lits == 1) {
        unsatisfied_weight += cl->weight;
      }
    }

    // Loop over unsatisfied clauses containing the "false" literal
    for (int c = 0; c < not_occ; c++) {
      int c_idx = not_l->clause_indexes[c];
      clause_t *cl = &clauses[c_idx];
      if (cl->sat_lits == 0) {
        satisfied_weight = cl->weight;
      }
    }

    // Determine if flipping the truth value of the "true" literal
    // will result in more satisfied weight than unsatisfied weight
    if (satisfied_weight - unsatisfied_weight >= 0.0) {
      if (assigned)
        greatest_reduction_cost_lits[num_reducing_lits++] = i;
      else
        greatest_reduction_cost_lits[num_reducing_lits++] = i + num_vars;
    }
  }
}

/** @brief Transfers weight from one clause to another in the distribute step.
 *
 *  Since the transferral was specified one way for the discrete case, I
 *  will be playing around with the continuous case here. For now, the
 *  weight is distributed by
 *   
 *   - halving the weight of the satisfied clause
 *   - adding that weight to the unsatisfied clause
 */
static inline void transfer_weight(clause_t *from, clause_t *to) {
  from->weight /= 2.0;
  to->weight += from->weight;
}

/** @brief Distribute weights from satisfied to unsatisfied clauses.
 *  
 *  In the case where no literals may be flipped to decrease the weight
 *  of the unsat clauses, the weight will be re-distributed from satisfied
 *  to unsatisfied clauses according to the following rule:
 *
 *  for each unsatisfied clause c,
 *    select a satisfied same sign neighboring clause cn with max weight wn
 *
 */
static void distribute_weights() {
  verbose_printf("c Distributing weights\n");

  // Loop over all clauses, picking out those that are false
  for (int c = 0; c < num_clauses; c++) {
    clause_t *cl = &clauses[c];
    if (cl->sat_lits > 0)
      continue;

    int size = cl->size;
    int max_neighbor_idx = -1;
    double max_neighbor_weight = -1.0;

    // Loop over the literals in the cl clause
    for (int l = 0; l < size; l++) {
      int l_idx = cl->literals[l];
      literal_t *l = &literals[l_idx];
      int occ = l->occurrences;

      // For each literal, search its neighbors for a satisfied clause
      for (int cn = 0; cn < occ; cn++) {
        int c_idx = l->clause_indexes[cn];
        clause_t *c_neigh = &clauses[c_idx];
        if (c_neigh->sat_lits > 0 && c_neigh->weight > max_neighbor_weight) {
          max_neighbor_idx = c_idx;
          max_neighbor_weight = c_neigh->weight;
        }
      }
    }

    if (max_neighbor_idx != -1) {
      clause_t *c_neigh = &clauses[max_neighbor_idx];
      transfer_weight(c_neigh, cl);
    } else {
      fprintf(stderr, "c NO MAX NEIGHBOR WEIGHT FOUND\n");
    }
  }
}

static void run_algorithm() {
  initialize_algorithm();

  // Record the time to ensure no timeout
  int timeout_loop_counter = DEFAULT_LOOPS_PER_TIMEOUT_CHECK;
  int seconds_at_start = time(NULL) / 3600;
  int lit_to_flip;
  while (unsat_clauses > 0) {
    find_cost_reducing_literals();

    verbose_printf("c Found %d cost reducing literals\n", num_reducing_lits);
    
    // See if any literals will reduce the weight
    // TODO no check against delta(W) = 0
    if (num_reducing_lits > 0) {
      int rand_lit = rand() % num_reducing_lits;
      lit_to_flip = greatest_reduction_cost_lits[rand_lit];
    } else {
      distribute_weights();
      continue;
    }

flip:
    flip_literal(lit_to_flip);
    sleep(1);

    if (verbose)
      print_loop_info();

    // Determine if enough loops have passed to update time variable
    timeout_loop_counter--;
    if (timeout_loop_counter == 0) {
      timeout_loop_counter = DEFAULT_LOOPS_PER_TIMEOUT_CHECK;
      if ((time(NULL) / 3600) - seconds_at_start >= timeout_secs)
        break;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// Main execution
////////////////////////////////////////////////////////////////////////////////

/** @brief Main function. Processes input arguments and kicks off solver.
 *
 *  @param argc The number of arguments to the command line.
 *  @param argv The array of string arguments given on the command line.
 */
int main(int argc, char *argv[]) {
  if (argc == 1 || argc > MAX_CLI_ARGS) {
    print_usage(argv[0], stderr);
    exit(1);
  }

  char *filename = NULL;
  extern char *optarg;
  char opt;
  while ((opt = getopt(argc, argv, "hvf:s:t:")) != -1) {
    switch (opt) { 
      case 'h':
        print_help(argv[0], stderr);
        break;
      case 'v':
        verbose = 1;
        break;
      case 'f':
        filename = optarg;
        break;
      case 's':
        seed = atoi(optarg);
        break;
      case 't':
        timeout_secs = atoi(optarg);
        break;
      default:
        print_usage(argv[0], stdout);
    }
  }

  verbose_printf("All done parsing CLI args, opening file...\n");

  if (filename == NULL) {
    fprintf(stderr, "No filename provided, exiting.\n");
    exit(1);
  }

  parse_cnf_file(filename);
  run_algorithm();

  return 0;
}
